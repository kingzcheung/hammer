package box

import (
	"archive/zip"
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

const defaultNamePackage = "hammer"

type zbox struct {
	zw          *zip.Writer
	bf          *bytes.Buffer
	srcDir      string
	namePackage string
	forceRemove bool
	namespace   string
}

func (z *zbox) SetNamespace(name string) {
	z.namespace = name
}

func (z *zbox) SetForceRemove(forceRemove bool) {
	z.forceRemove = forceRemove
}

func (z *zbox) SetNamePackage(namePackage string) {
	// 驼峰转下划线
	var b bytes.Buffer
	for i, n := range namePackage {
		if n >= 65 && n <= 90 {
			if i != 0 {
				b.WriteString(`_`)
			}
			b.WriteRune(n + 32)
			continue
		}
		if n >= 97 && n <= 122 {
			b.WriteRune(n)
			continue
		}
		if n == '_' {
			b.WriteString(`_`)
			continue
		}
	}

	z.namePackage = b.String()
}

func NewZbox(dir string) *zbox {
	var (
		bf    = new(bytes.Buffer)
		write io.Writer
	)
	write = bf
	return &zbox{
		bf:          bf,
		zw:          zip.NewWriter(write),
		srcDir:      dir,
		namePackage: defaultNamePackage,
		namespace:   dir,
	}
}

func (z *zbox) mkdir() error {
	b := pathExists(z.namePackage)
	if b {
		if !z.forceRemove {
			return errors.New("path exists")
		}
		err := os.RemoveAll(z.namePackage)

		if err != nil {
			return err
		}
	}
	return os.MkdirAll(z.namePackage, 0755)
}

func (z *zbox) write() error {

	if err := z.mkdir(); err != nil {
		return err
	}

	err := filepath.Walk(z.srcDir, func(path string, info os.FileInfo, err error) error {

		path = filepath.ToSlash(path)

		if info.IsDir() || strings.HasPrefix(info.Name(), ".") {
			return nil
		}

		fh, err := zip.FileInfoHeader(info)

		if err != nil {
			return err
		}
		fh.Method = zip.Deflate
		// 需要记录文件相对于原始目录的相对目录

		var rel string
		if z.srcDir != path {
			rel, err = filepath.Rel(z.srcDir, path)
			if err != nil {
				return err
			}
		} else {
			_, rel = filepath.Split(z.srcDir)
		}
		fh.Name = rel
		fmt.Println("file::", rel)
		zc, err := z.zw.CreateHeader(fh)
		if err != nil {
			return err
		}

		file, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}
		_, err = zc.Write(file)

		if err != nil {
			return err
		}

		return nil
	})
	if err != nil {
		return err
	}

	return z.zw.Close()
}

func (z *zbox) codeGenerate() error {
	var (
		bf bytes.Buffer
	)

	bf.WriteString(`// Code generated by hammer. DO NOT EDIT.`)
	bf.WriteString("\n")
	bf.WriteString("package " + z.namePackage)
	bf.WriteString(`
import (
	"github.com/kingzcheung/hammer/box"
)

`)
	bf.WriteString(`const zipMap = "`)
	bf.Write(convertsBytes(z.bf.Bytes()))
	bf.WriteString("\"\n")
	bf.WriteString("func init() {box.ReadFromZipData(")
	bf.WriteString("\"")
	bf.WriteString(z.namespace)
	bf.WriteString("\"")
	bf.WriteString(", zipMap);}\n")

	filename := fmt.Sprintf("%s/%s.go", z.namePackage, z.namePackage)
	if err := ioutil.WriteFile(filename, bf.Bytes(), 0644); err != nil {
		return err
	} else {
		return nil
	}
}

func (z *zbox) Hammer() error {
	err := z.write()
	if err != nil {
		return err
	}
	return z.codeGenerate()
}

func convertsBytes(data []byte) []byte {
	var bf bytes.Buffer
	for _, b := range data {
		if b == '\n' {
			bf.WriteString(`\n`)
			continue
		}
		if b == '\\' {
			bf.WriteString(`\\`)
			continue
		}
		if b == '"' {
			bf.WriteString(`\"`)
			continue
		}
		if (b >= 32 && b <= 126) || b == '\t' {
			bf.WriteByte(b)
			continue
		}

		bf.WriteString(fmt.Sprintf("\\x%02x", b))
	}
	return bf.Bytes()
}

func pathExists(path string) bool {
	_, err := os.Stat(path) // os.Stat获取文件信息
	if err != nil {
		if os.IsExist(err) {
			return true
		}
		return false
	}
	return true
}
